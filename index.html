<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>JavaScript - A Brief Overview</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/custom.css">
		<link rel="stylesheet" href="css/theme/black.css" id="theme">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>JavaScript</h1>
					<h3>A Brief Overview</h3>
				</section>

				<section>
					<h2 class="fragment fade-out" data-fragment-index="1">Agenda</h2>
					<ol>
						<li class="fragment highlight-green" data-fragment-index="1">ES2015 / ES2016 / ES2017 Features</li>
						<li>Promises and Async/Await</li>
						<li>Transpiling</li>
						<li>Common Libraries</li>
						<li>Linting / Testing</li>
					</ol>
				</section>

				<section>
					<section>
						<h3>Preface: Version Terminology</h3>
						<table>
							<tr>
								<td><span style="color:red">ES6</span></td>
								<td><span style="color:green">ES2015</span></td>
							</tr>
							<tr>
								<td><span style="color:red">ES7</span></td>
								<td><span style="color:green">ES2016</span></td>
							</tr>
							<tr>
								<td><span style="color:red">ES8</span></td>
								<td>
									<span style="color:green">ES2017</span>
								</td>
							</tr>
							<tr>
								<td>Proposed Features</td>
								<td>
									<span style="color:green">ES.Next</span>
								</td>
							</tr>
						</table>

						<aside class="notes">
							ECMAScripts is a specification of a scripting language. The specification was made particularly
							for JavScript, although other languages can be built off the specification (ActionScript). The
							formal specification body has in the past faced major internal political differences
							(particularly with the 4th edition which led to a 10 year gap in edition releases). ES is now
							heavily influenced by large companies like Mozilla, Microsoft, Google, and Netflix and has moved
							to a commitment of iterative yearly releases. So, versions are encouraged to be referred to by
							their year tag and not edition tag.
						</aside>
					</section>

					<section>
						<table>
							<tr>
								<td>Stage 0:</td>
								<td>Strawman.</td>
							</tr>
							<tr>
								<td style="white-space:nowrap">Stage 1:</td>
								<td>Proposal. Committee is devoting time to investigate.</td>
							</tr>
							<tr>
								<td>Stage 2:</td>
								<td>Draft. Committee expects the feature to be developed.</td>
							</tr>
							<tr>
								<td>Stage 3:</td>
								<td>Candidate. Feature complete. Awaiting significant usage and external feedback.</td>
							</tr>
							<tr>
								<td>Stage 4:</td>
								<td>Ready for inclusion. Included in the next standard revision.</td>
							</tr>
						</table>
						<small>Track committee progress on language features here: https://tc39.github.io/</small>
						<aside class="notes">
							It is important to keep in mind the maturity of features when actively developing in JavScript.
							By the nature of the language, transpiling has become an important intermediary step. Transpiling
							can allow you to do some dangerous things when developing a production application so keep
							these stages in mind. You only want to include stage 4 features in production.
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h2>ES2015 Features</h2>
					</section>
					<section>
						<h3>Arrow Functions</h3>
						<pre><code class="hljs" data-trim>
const values = [1,2,3,4];
let total;

//ES5
total = values.reduce(function(a,b) {
	return a + b;
}, 0);

//ES2015
total = values.reduce((a,b) => a + b, 0);
						</code></pre>
						<p>Shorter function syntax improve readability. Especially when deeply nested or passed in arguments.</p>
						<aside class="notes">
							Arrows are a function shorthand with the added property that they share the same lexical
							"this" as their surrounding code. this new construct is particularly useful in functional
							programming, however, it's lexical "this" binding also makes it
						</aside>
					</section>
					<section>
						<small>Enhanced Object Literals</small>
						<pre><code class="hljs" data-trim>
let foo = 'b';

const obj = {
	// __proto__
	__proto__: theProtoObj,
	// Shorthand for 'foo: foo'
	foo,
	// Methods
	toString() {
	   //Can make Super calls
	   return 'd' + super.toString();
	}
}

						</code></pre>
						<aside class="notes">
							Object literals already existed, however, ES2015 brought about several enhancements allowing
							for directly setting the prototype, reducing redundant decelerations, and declaring functions
							in line that can even reference super.
						</aside>
					</section>
					<section>
						<small>Template Strings</small>
						<pre class="fragment current-visible"><code class="hljs" data-trim>
let a = 5;
let b =	10;
console.log(`Fifteen is ${a + b} and not ${2 * a + b}`);
// Fifteen is 15 and not 20
						</code></pre>
						<pre class="fragment current-visible"><code class="hljs" data-trim>
const person = 'Mike';
const age = 28;

function myTag(strings, personExp, ageExp) {
  let ageStr;
  if (ageExp > 99){
    ageStr = 'centenarian';
  } else {
    ageStr = 'youngster';
  }
  return strings[0] + personExp + strings[1] + ageStr;
}

var output = myTag`that ${ person } is a ${ age }`;

console.log(output); // that Mike is a youngster
						</code></pre>
						<aside class="notes">
							Adds string interpolation features present in most other scripting languages.
						</aside>
					</section>
					<section>
						<small>Destructuring</small>
						<pre class="fragment current-visible"><code class="hljs" data-trim>
function f() { return [1, 2]; }
let [a, b] = f();

console.log(a); // 1
console.log(b); // 2
						</code></pre>
						<pre class="fragment current-visible"><code class="hljs" data-trim>
let metaData = {
	name: 'Mike Smith',
	family: {
		mother: 'Jane Smith',
		father: 'Harry Smith'
	}
}

let {name, family: {mother: mothersName} } = metaData;

console.log(name); // Mike Smith
console.log(mothersName); // Jane Smith
						</code></pre>
					</section>
					<section>
						<small>Default</small>
						</code></pre>
						<pre><code class="hljs" data-trim>
function f(x, y=12) {
  // y is 12 if not passed (or passed as undefined)
  return x + y;
}
f(3) === 15
						</code></pre>
						<small>Rest</small>
						</code></pre>
						<pre><code class="hljs" data-trim>
function f(x, ...y) {
  // y is an Array
  return x * y.length;
}
f(3, "hello", true) === 6
						</code></pre>
						<small>Spread</small>
						</code></pre>
						<pre><code class="hljs" data-trim>
function f(x, y, z) {
  return x + y + z;
}
// Pass each elem of array as argument
f(...[1,2,3]) == 6
						</code></pre>
					</section>
					<section>
						<small>Let: declare variables limited in scope to block they were declared</small>
						<pre><code class="hljs" data-trim>
function varTest() {
  var x = 1;
  if (true) {
    var x = 2;  // same variable!
    console.log(x);  // 2
  }
  console.log(x);  // 2
}

function letTest() {
  let x = 1;
  if (true) {
    let x = 2;  // different variable
    console.log(x);  // 2
  }
  console.log(x);  // 1
}
						</code></pre>
						<aside class="notes">
							'let' allows you to declare variables that are limited in scope to the block, statement, or
							expression on which it is used. This is unlike the var keyword, which defines a variable
							globally, or locally to an entire function regardless of block scope.
						</aside>
					</section>
					<section>
						<small>Const: same scoping rules as let, without ability for re-assignment or re-deceleration</small>
						<pre><code class="hljs" data-trim>
const FOO = 5;
// trying to redeclare a constant throws an error
FOO = 42;
// FOO is reserved, this fails
let FOO = 42;
if(true) {
	// This is OK (new scope)
	let FOO = 42;
}
if(true) {
	// This is not OK (var is hoisted to global scope)
	var FOO = 12;
}
						</code></pre>
						<aside class="notes">
							The const declaration creates a read-only reference to a value. It does not mean the value
							it holds is immutable, just that the variable identifier cannot be reassigned. For instance,
							in the case where the content is an object, this means the object's contents
							(e.g. its parameters) can be altered.
						</aside>
					</section>

				</section>
				<section>
					<section>
						<h2>ES2016 Features</h2>
					</section>
					<section>
						<h3>Exponential Operator</h3>
						<pre><code class="hljs" data-trim>
2**5 === Math.pow(2,5) // true
						</code></pre>
						<p class="fragment current-visible">Neat.</p>
					</section>
					<section>
						<h3>Array.prototype.includes</h3>
						<pre><code class="hljs" data-trim>
['a','b','c'].includes('a'); // true
[NaN, 1, 2].includes(NaN); // true
						</code></pre>
						<p class="fragment current-visible">Neat.</p>
					</section>
				</section>
				<section>
					<section>
						<h2>ES2017 Features</h2>
					</section>

					<section>
						<h3>Shared Memory and Atomics</h3>
						<ul class="fragment current-visible">
							<li>New SharedArrayBuffer primitive allows sharing between workers and the main thread</li>
							<li>New Atomics methods for synchronizing workers</li>
						</ul>
						<small class="fragment current-visible">Interesting topic for the future of JavaScript, but, outside the scope of anything we will
						practically be using now. See for more info: https://hacks.mozilla.org/2016/05/a-taste-of-javascripts-new-parallel-primitives/ </small>
					</section>

					<section>
						<h3>Async Functions</h3>
					</section>
				</section>
				<section>
					<ol>
						<li>ES2015 / ES2016 / ES2017 Features</li>
						<li class="fragment highlight-green" data-fragment-index="1">Promises and Async/Await</li>
						<li>Transpiling</li>
						<li>Common Libraries</li>
						<li>Linting / Testing</li>
					</ol>
				</section>
				<section>
					<section>
						Promises - representation of a value that may be made available in the future.
						<img class="plain"  src="images/Promise.PNG"/>
						<aside class="notes">
							Promises are a library for asynchronous programming. Promises are a first class
							representation of a value that may be made available in the future. It allows you to
							associate handlers with an asynchronous action's eventual success value or failure reason.

							Examples from: https://github.com/mattdesl/promise-cookbook
						</aside>
					</section>
					<section>
						<small>callbacks (the old way of async)</small>
					    <pre><code class="hljs" data-trim>
function loadImage(url, callback) {
  var image = new Image();

  image.onload = function() {
    callback(null, image);
  };

  image.onerror = function() {
    callback(new Error('whoops'));
  };

  image.src = url;
}
						</code></pre>
						<small>loading one image isn't bad!</small>
						<pre><code class="hljs" data-trim>
loadImage('one.png', function(err, image) {
  if (err) throw err;
  console.log('Image loaded', image);
});
						</code></pre>
					</section>
					<section>
						<small>loading 3 is sad.</small>
						<pre><code class="hljs" data-trim>
loadImage('one.png', function(err, image1) {
  if (err) throw err;

  loadImage('two.png', function(err, image2) {
    if (err) throw err;

    loadImage('three.png', function(err, image3) {
      if (err) throw err;

      var images = [image1, image2, image3];
      console.log('All images loaded', images);
    });
  });
});
						</code></pre>
					</section>
					<section>
						<pre><code class="hljs" data-trim>
function loadImageAsync(url) {
  return new Promise( (resolve, reject) => {
    var image = new Image();
    image.onload = () => {
      resolve(image);
    };

    image.onerror = () => {
      reject(new Error('whoops'));
    };

    image.src = url;
  });
}
						</code></pre>
						<small>loading one image isn't bad!</small>
						<pre><code class="hljs" data-trim>
loadImageAsync('one.png')
  .then(function(image) {
    console.log('Image loaded', image);
  }).catch(err) {
    console.error('Error loading image', err);
  });
						</code></pre>
					</section>
					<section>
						<small>Loading 3 is much more concise. Also, async.</small>
					   <pre><code class="hljs" data-trim>
const urls = ['one.png', 'two.png', 'three.png'];
const promises = urls.map(loadImageAsync);

Promise.all(promises)
  .then(function(images) {
    console.log('All images loaded', images);
  })
  .catch(function(err) {
    console.error(err);
  });
						</code></pre>
					</section>
					<section>
						<small>Promises chain</small>
						<pre><code class="hljs" data-trim>
loadImageAsync('one.png')
  .catch( (err) => {
    console.warn(err.message);
    return loadImageAsync('not-found.png');
  })
  .then( (image) => {
    console.log('Resolved image', image);
  })
  .catch( (err) => {
    console.error('Could not load any images', err);
  });
						</code></pre>
					</section>
					<section>
						<small>Promise control flow</small>
						<pre><code style="font-size:15px; line-height: normal" class="hljs" data-trim>
function loadImages(urls) {
  const promises = urls.map(loadImageAsync);
  return Promise.all(promises);
}

function getUserImages(user) {
  return loadUserData(user)
    .then((userData) => {
      return loadImages(userData.imageUrls);
    });
}

function showUserImages(user) {
  return getUserImages(user)
    .then(renderGallery)
    .catch(renderEmptyGallery);
}

showUserImages('foo')
						</code></pre>
					</section>
					<section>
						<small>Promise resolve/reject</small>
						<pre><code class="hljs" data-trim>
function loadImageAsync(url) {
  if (typeof url !== 'string') {
    return Promise.reject(new TypeError('must specify a string'));
  }

  return new Promise(function (resolve, reject) {
    /* async code */
  });
}
						</code></pre>
					</section>
					<section>
						<small>Async Functions</small>
						<pre><code style="font-size:15px; line-height: normal" class="hljs" data-trim>
function loadImages(urls) {
  const promises = urls.map(loadImageAsync);
  return Promise.all(promises);
}

async function getUserImages(user) {
  const userData = await loadUserData(user);
  return loadImages(userData.imageUrls)
}

async function showUserImages(user) {
  try {
    const images = await getUserImages(user);
	renderGallery(images);
  } catch(err) {
	renderEmptyGallery();
  }
}


showUserImages('foo')
						</code></pre>
					</section>
				</section>
				<section>
					<ol>
						<li>ES2015 / ES2016 / ES2017 Features</li>
						<li>Promises and Async/Await</li>
						<li class="fragment highlight-green" data-fragment-index="1">Transpiling</li>
						<li>Common Libraries</li>
						<li>Linting / Testing</li>
					</ol>
				</section>
				<section>
					<section>
						<h2>Transpiling</h2>

						<aside class="notes">
							With such crucial features introduced in new ES versions, as well as features that are Stage 4
							(ready to use) and simply waiting for the next release, you may wonder what needs to be done to
							begin developing with the latest stable ES feature set in your environment. Enter, transpiling.
							Transpiling stands for transformation and compiling. It is a tool for converting ES2015+ code
							into code that works on ES2015 environments. With transpiling, you write your code with the latest
							language features, and simply introduce a build step which generates a distributable version of
							your code that is usable in all of your target environments. The tool used in this build step
							is called Babel.
						</aside>
					</section>
					<section>
						<small>This ES2017 code:</small>
						<pre><code class="hljs" data-trim>
async function foo(promise) {
  const result = await promise;
  return result
}
						</code></pre>
						<small>Becomes this ES2015 code when run through Babel:</small>

						<pre><code class="hljs" data-trim>
let foo = (() => {
  var _ref = _asyncToGenerator(function* (promise) {
    const result = yield promise;
    return result;
  });

  return function foo(_x) {
    return _ref.apply(this, arguments);
  };
})();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
						</code></pre>
						<aside class="notes">
							Notice, babel here is configured to transpile for versions of Node less than 7.6 (before Node
							used a version of V8 supporting async/await). The current LTS is 6.11. So, if you wanted to use
							the latest LTS of node and also use latest ES features, you would need either this step or a polyfill
							for your code to work properly. Babel can be configured to transpile targeting the environment
							your code is running in. This means that if you were using a later version of Node your code when
							run through the transpiler would look exactly the same.
						</aside>
					</section>
					<section>
						<p>Adding Transpiling to Your Application</p>

					</section>
				</section>
			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
